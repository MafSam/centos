--- a/arch/x86/kernel/cpu/bugs.c	2019-07-18 12:58:03.000000000 -0700
+++ b/arch/x86/kernel/cpu/bugs.c	2019-08-07 23:20:28.694377902 -0700
@@ -28,7 +28,70 @@
 #include <asm/intel-family.h>
 #include <linux/prctl.h>
 #include <linux/sched/smt.h>
+ 
+static int __init no_387(char *s)
+{
+	boot_cpu_data.hard_math = 0;
+	write_cr0(X86_CR0_TS | X86_CR0_EM | X86_CR0_MP | read_cr0());
+	return 1;
+}
+
+__setup("no387", no_387);
+
+static double __initdata x = 4195835.0;
+static double __initdata y = 3145727.0;
+
+/*
+ * This used to check for exceptions..
+ * However, it turns out that to support that,
+ * the XMM trap handlers basically had to
+ * be buggy. So let's have a correct XMM trap
+ * handler, and forget about printing out
+ * some status at boot.
+ *
+ * We should really only care about bugs here
+ * anyway. Not features.
+ */
+static void __init check_fpu(void)
+{
+	s32 fdiv_bug;
+
+	if (!boot_cpu_data.hard_math) {
+#ifndef CONFIG_MATH_EMULATION
+		pr_emerg("No coprocessor found and no math emulation present\n");
+		pr_emerg("Giving up\n");
+		for (;;) ;
+#endif
+		return;
+	}
 
+	kernel_fpu_begin();
+
+	/*
+	 * trap_init() enabled FXSR and company _before_ testing for FP
+	 * problems here.
+	 *
+	 * Test for the divl bug: http://en.wikipedia.org/wiki/Fdiv_bug
+	 */
+	__asm__("fninit\n\t"
+		"fldl %1\n\t"
+		"fdivl %2\n\t"
+		"fmull %2\n\t"
+		"fldl %1\n\t"
+		"fsubp %%st,%%st(1)\n\t"
+		"fistpl %0\n\t"
+		"fwait\n\t"
+		"fninit"
+		: "=m" (*&fdiv_bug)
+		: "m" (*&x), "m" (*&y));
+
+	kernel_fpu_end();
+
+	if (fdiv_bug) {
+		set_cpu_bug(&boot_cpu_data, X86_BUG_FDIV);
+		pr_warn("Hmm, FPU with FDIV bug\n");
+	}
+}
 
 static void __init spectre_v2_select_mitigation(void);
 static void __init ssb_parse_cmdline(void);
@@ -926,8 +989,10 @@ static ssize_t cpu_show_common(struct de
 
 	switch (bug) {
 	case X86_BUG_CPU_MELTDOWN:
+#ifdef CONFIG_KAISER
 		if (kaiser_enabled)
 			return sprintf(buf, "Mitigation: PTI\n");
+#endif
 
 		break;
 
